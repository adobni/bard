parser grammar TParser;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Produce an AST
    //
    output    = AST;

    // Use a superclass to implement all helper
    // methods, instance variables and overrides
    // of ANTLR default methods, such as error
    // handling.
    //
    superClass = AbstractTParser;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = TLexer;


}

// Import a grammar file, even though it does not really need it in this
// simle demo parser. We do the import to show where imported grammars should be
// stored for maven builds.
//
//import Ruleb;

// Some imaginary tokens for tree rewrites
//
tokens {
    SCRIPT;
}

// What package should the generated source exist in?
//
@header {

    package org.shakespearelang.bard;
}

startsymbol : play;

play :  title characterdeclarationlist act |
        act play;
/*play : title characterdeclarationlist error;
play : title error act;
play : error characterdeclarationlist act; */

title : string endsymbol;


act : actheader scene 
    | scene act;

actheader : Act_roman Colon Comment endsymbol;

characterdeclaration : Character Comma comment endsymbol;
/* characterdeclaration : error Comma comment endsymbol;
characterdeclaration : Character error comment endsymbol; */

characterdeclarationlist : characterdeclaration+;
                           // |  characterdeclarationlist characterdeclaration;
/* characterdeclarationlist : characterdeclarationlist characterdeclaration; */

characterlist :  Character And Character |
                Character Comma characterlist;

scene : sceneheader scenecontents;

scenecontents :  enterexit scenecontents?|
                 line scenecontents?;

sceneheader : Scene_roman Colon comment endsymbol;
/* sceneheader : scene_roman Colon comment error;
sceneheader : scene_roman error comment endsymbol; */


//string : stringsymbol;
string : stringsymbol
    | stringsymbol string;


adjective : Positive_adjective |
            Neutral_adjective |
            Negative_adjective;

binaryoperator : The_difference_between |
                  The_product_of |
                  The_quotient_between |
                  The_remainder_of_the_quotient_between |
                  The_sum_of;


comment : string;
/* comment : error; */

comparative :  negativecomparative |
               positivecomparative;

comparison :  Not nonnegatedcomparison |
              nonnegatedcomparison;



constant :  Article unarticulatedconstant |
            First_person_possessive unarticulatedconstant |
            Second_person_possessive unarticulatedconstant |
            Third_person_possessive unarticulatedconstant |
            Nothing;

endsymbol :  questionsymbol |
             statementsymbol;

enterexit :  Left_bracket Enter Character Right_bracket |
             Left_bracket Enter characterlist Right_bracket |
             Left_bracket Exit Character Right_bracket |
             Left_bracket Exeunt characterlist Right_bracket |
             Left_bracket Exeunt Right_bracket;
/* enterexit : Left_bracket Enter error Right_bracket;
enterexit : Left_bracket Exit error Right_bracket;
enterexit : Left_bracket Exeunt error Right_bracket;
enterexit : Left_bracket Error Right_bracket; */

equality : As Adjective As;
/* equality : as error as;
equality : as adjective error; */

inequality : comparative Than;
// inequality : comparative error;


line : Character Colon sentencelist;
/*line : Character Colon error;
line : Character error sentencelist;*/

negativecomparative :  Negative_comparative |
                       More Negative_adjective |
                       Less Positive_adjective;


nonnegatedcomparison :  equality |
                        inequality;




positivecomparative :  Positive_comparative |
                       More Positive_adjective |
                       Less Negative_adjective;



pronoun :  First_person |
           First_person_reflexive |
           Second_person |
           Second_person_reflexive;





sentencelist : sentence |
               (sentence sentencelist) => sentence sentencelist;

sentence :  (conditional) => conditional Comma unconditionalsentence |
            unconditionalsentence
         ;
//sentence : conditional error unconditionalsentence;


conditional :  If_so |
               If_not;

unconditionalsentence :  inout |
                         jump |
                         question |
                         recall |
                         remember |
                         statement;

inout :  openyour Heart statementsymbol |
         Speak Second_person_possessive Mind statementsymbol |
         Listen_to Second_person_possessive Heart statementsymbol |
         openyour Mind statementsymbol;

/* inout : openyour error statementsymbol;
inout : speak error mind statementsymbol;
inout : listen_to error heart statementsymbol;
inout : speak Second_person_possessive error statementsymbol;
inout : listen_to Second_person_possessive error statementsymbol;
inout : openyour heart error;
inout : speak Second_person_possessive mind error;
inout : listen_to Second_person_possessive heart error;
inout : openyour mind error;
*/


openyour : Open Second_person_possessive;
// openyour : open error;


jump :  jumpphrase Act_roman statementsymbol |
        jumpphrase Scene_roman statementsymbol;
// jump : jumpphrase error statementsymbol;


jumpphrase : jumpphrasebeginning jumpphraseend;
//jumpphrase : error jumpphraseend;
//jumpphrase : jumpphrasebeginning error;


jumpphrasebeginning :  Let_us |
                       We_must |
                       We_shall;


jumpphraseend :  Proceed_to |
                 Return_to;


question : Be value comparison value questionsymbol;
/* question : be error comparison value questionsymbol;
question : be value error value questionsymbol;
question : be value comparison error questionsymbol; */


recall : Recall string statementsymbol;
//         recall error statementsymbol;
//recall string error;


remember : Remember value statementsymbol;
/*remember : remember error statementsymbol;
remember : remember value error; */


statement :  Second_person ( Be constant statementsymbol |
                             unarticulatedconstant statementsymbol |
                             Be equality value statementsymbol );
/* statement : Second_person be constant error;
statement : Second_person be error statementsymbol;
statement : Second_person error constant statementsymbol;
statement : Second_person unarticulatedconstant error;
statement : Second_person error statementsymbol;
statement : Second_person be equality value error;
statement : Second_person be equality error statementsymbol;
statement : Second_person be error value statementsymbol;
statement : Second_person error equality value statementsymbol; */



unarticulatedconstant :  (positiveconstant) => positiveconstant |
                         negativeconstant;


positiveconstant :  positivenoun |
                    Positive_adjective positiveconstant |
                    Neutral_adjective positiveconstant;


negativeconstant :  negativenoun |
                    Negative_adjective negativeconstant |
                    Neutral_adjective negativeconstant;


positivenoun :  Neutral_noun |
               Positive_noun;


negativenoun : Negative_noun;


unaryoperator :  The_cube_of |
                 The_factorial_of |
                 The_square_of |
                 The_square_root_of |
                 Twice;


value :  Character |
         constant |
         pronoun |
         binaryoperator value And value |
         unaryoperator value;
/*value : binaryoperator value And error;
value : binaryoperator value error value;
value : binaryoperator error And value;
value : unaryoperator error; */

stringsymbol :  Article |
                Be |
                Character |
                First_person |
                First_person_possessive |
                First_person_reflexive |
                Negative_adjective |
                Negative_comparative |
                Negative_noun |
                Neutral_adjective |
                Neutral_noun |
                Nothing |
                Positive_adjective |
                Positive_comparative |
                Positive_noun |
                Second_person |
                Second_person_possessive |
                Second_person_reflexive |
                Third_person_possessive |
                Comma |
                And |
                As |
                Enter |
                Exeunt |
                Exit |
                Heart |
                If_not |
                If_so |
                Less |
                Let_us |
                Listen_to |
                Mind |
                More |
                Not |
                Open |
                Proceed_to |
                Recall |
                Remember |
                Return_to |
                Speak |
                Than |
                The_cube_of |
                The_difference_between |
                The_factorial_of |
                The_product_of |
                The_quotient_between |
                The_remainder_of_the_quotient_between |
                The_square_of |
                The_square_root_of |
                The_sum_of |
                Twice |
                We_must |
                We_shall |
                Act_roman |
                Scene_roman |
                Roman_number |
                Nonmatch;
 
questionsymbol : Question_mark;

statementsymbol :  Exclamation_mark |
                   Period;

           